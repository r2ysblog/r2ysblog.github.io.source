[{"categories":["翻译"],"content":" 人各有志：Everyone has his own ambition/aspiration.  ","date":"2022-03-10","permalink":"/posts/notes/%E6%AF%8F%E6%97%A5%E7%BF%BB%E8%AF%91%E4%BE%8B%E5%8F%A5/","series":[],"tags":["翻译","英语"],"title":"每日翻译例句"},{"categories":["分布式"],"content":" https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==\u0026amp;mid=2247500380\u0026amp;idx=1\u0026amp;sn=025c1c9fcdba8e72a5eb2e8c8aad98fd\u0026amp;chksm=e92aff53de5d76454f580f3adebda282f31d3f97a3d5c6f8cdb9c2d5d8283b1719263368753b\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=1028xGhlHoY5tz23wMlOVs1C\u0026amp;sharer_sharetime=1603845682194\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95epaxos/","series":[],"tags":["一致性","算法"],"title":"分布式一致性算法EPaxos.md"},{"categories":["权限"],"content":"目前常用的几种可选框架 sa-token https://mp.weixin.qq.com/s?__biz=MzU3MDc3OTI1NA==\u0026amp;mid=2247490668\u0026amp;idx=1\u0026amp;sn=cd9efecdf1ac34cc8cac04902a9f8319\u0026amp;chksm=fceb6f75cb9ce663f818cbaaa78e5d9eb9d8142f721e9385056ad9f68f7277acd03c509fe531\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=0321KOsiEPuUB5RpsMsy6y9g\u0026amp;sharer_sharetime=1616285588520\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81%E6%A1%86%E6%9E%B6%E6%80%8E%E4%B9%88%E9%80%89/","series":[],"tags":["SpringSecurity","Shiro","sa-token"],"title":"权限认证框架怎么选.md"},{"categories":["MySQL"],"content":" https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==\u0026amp;mid=2651967369\u0026amp;idx=1\u0026amp;sn=d639abf6772a72c25cc2537749258163\u0026amp;chksm=bd2d7a558a5af3436e0a435a3e7cd9f72f67c1269370be936a82dc0af483f47aefa48bd58d69\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=0427iuPM9K3Qh3Ds8LvD8m2E\u0026amp;sharer_sharetime=1619533884103\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%AD%A6%E4%BC%9Ainnodb%E5%90%84%E7%A7%8D%E9%94%81/","series":[],"tags":["Innodb","锁"],"title":"学会Innodb各种锁.md"},{"categories":["Spring"],"content":" https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==\u0026amp;mid=2247503481\u0026amp;idx=1\u0026amp;sn=c85ae5d031b8b27b267a277484c05c87\u0026amp;chksm=e92af376de5d7a604d5f0c0078c5f3de4e5ac3540a018b1cc0ecf434ea90db1aac8f0150d1fe\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=0520kljGHoaZJv6QcY41Fh2d\u0026amp;sharer_sharetime=1621485378939\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%80%8E%E4%B9%88%E5%81%9A%E6%9B%B4%E4%BC%98%E9%9B%85/","series":[],"tags":["参数校验","Hibernate","Validate"],"title":"参数校验怎么做更优雅.md"},{"categories":["持续继承"],"content":"Jenkins的替代方案 https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==\u0026amp;mid=2651050229\u0026amp;idx=5\u0026amp;sn=af2d0f8fc317cb4d73b14fc0c10f442e\u0026amp;chksm=bdbe28a68ac9a1b0461e43ef836aa9bfa9f397c1738bc60dc8d34742fb0b0bedacd0c367915c\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=1112OHSz20a9MsKcNCtRODfZ\u0026amp;sharer_sharetime=1605160588581\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247518077\u0026amp;idx=1\u0026amp;sn=69cf89c46b453520460c0e375bfb3472\u0026amp;chksm=fa4af8cccd3d71dacc33bb6cfc3496af2d32fc4a1b5da32927ad7702b5baea2b6c2a3b3ab460\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=0612nZqBnjk98Ioh7rV6IvE4\u0026amp;sharer_sharetime=1623497834187\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/jenkins%E7%B1%BB%E7%9A%84%E5%B7%A5%E5%85%B7%E8%83%BD%E5%B8%AE%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88/","series":[],"tags":["Jenkins","CI","CD"],"title":"Jenkins类的工具能帮我们做什么.md"},{"categories":["插件"],"content":" Vert.x Core项目源码地址： https://github.com/eclipse-vertx/vert.x Zulu JDK下载地址：https://www.azul.com/downloads/zulu-community/?os=macos\u0026amp;package=jdk JDK 国内镜像站：https://www.injdk.cn 也可以找到适配M1 Mac的Zulu版本\n","date":"2021-06-29","permalink":"/posts/notes/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8Bvert.x%E5%85%A5%E9%97%A8/","series":[],"tags":["IDEA"],"title":"响应式编程Vert.x入门.md"},{"categories":["插件"],"content":"HttpClient插件 https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247505020\u0026amp;idx=1\u0026amp;sn=3075f2a466d1d2df949c63ae4393f81e\u0026amp;chksm=fa4aabcdcd3d22dbe79c200f0c087b9b404a5b01047ef4993b3512426209655493ecf9ad953b\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=12240mUmXWr6agTCvhkHbKkg\u0026amp;sharer_sharetime=1608818291964\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n文档生成插件 git提交插件 如何自己开发插件 https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==\u0026amp;mid=2247500551\u0026amp;idx=1\u0026amp;sn=0feada3f16404a10c9632689a060082e\u0026amp;chksm=e92afe08de5d771e153f5f91d60a169df29f2bec1afc481df550f1022bd1e8eccd9d9228dc00\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=1106mOqUWRt3EUcQS6fX1wYu\u0026amp;sharer_sharetime=1604622305608\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E7%94%A8%E5%A5%BDidea%E6%8F%92%E4%BB%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84/","series":[],"tags":["IDEA"],"title":"用好IDEA插件带来的好处.md"},{"categories":["单元测试"],"content":"阿里的mock工具有什么魔法 https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==\u0026amp;mid=2247501494\u0026amp;idx=1\u0026amp;sn=54d20391a4d0d3a8ddbbb2d4e777d771\u0026amp;chksm=e92afbb9de5d72af37fad640ba1401afb22fa1caf99eef58374c110abfcb0179cf1c8eaf39ce\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=1222b0NpB7mhljSLhpklzHbA\u0026amp;sharer_sharetime=1608595647786\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/","series":[],"tags":["Mock"],"title":"如何写好单元测试用例.md"},{"categories":["网关"],"content":"api网关设计的方方面面 https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247507916\u0026amp;idx=4\u0026amp;sn=b55ef35bce39ae448ad472e20393fb11\u0026amp;chksm=fa4aa07dcd3d296b7bfcb786975f7271e4184596c87e4a6d5ce17643bbdde452d08026950d67\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0205Rd3F9PaDvFcm4BrgbPLp\u0026amp;sharer_sharetime=1612493454398\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n如何设计 https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247507679\u0026amp;idx=3\u0026amp;sn=0e54bf6c578a85601e45a44bc8bfca0f\u0026amp;chksm=fa4aa16ecd3d2878ba5b7273b11b91302e31af04b75b3c0ac1f1408c8c4948f98fbc27e45356\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0201frLvZI3FLO5OoGr767hz\u0026amp;sharer_sharetime=1612155601583\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n开源API网关对比 https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247518160\u0026amp;idx=1\u0026amp;sn=00d4d72312ac8960c5523908feacc50b\u0026amp;chksm=fa4af861cd3d717724ab3bd58f254c9499b40a5343fe8e1758c91ab0fb0f13fe0172d5ce2506\u0026amp;mpshare=1\u0026amp;scene=24\u0026amp;srcid=0614RrmDpr1WiO6KEt2yPaQZ\u0026amp;sharer_sharetime=1623626262648\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AAapi%E7%BD%91%E5%85%B3/","series":[],"tags":[],"title":"如何做好一个API网关.md"},{"categories":["日志框架"],"content":"如何选择日志框架并解决冲突 logback配置文件 https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247507916\u0026amp;idx=3\u0026amp;sn=99226aa132805fcac3dec83f0d494acb\u0026amp;chksm=fa4aa07dcd3d296b70402e2dcc9ab5a6136df8eafdcc758b4223d9e4433d1bd022f228a2bcab\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0205CqK4JI2wmmpCogocXv4r\u0026amp;sharer_sharetime=1612493462792\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n配置日志链路 traceId MDC ","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","series":[],"tags":["logback","slf4j","log4j"],"title":"如何使用日志框架.md"},{"categories":["工作"],"content":"态度 在金科和惠金所合并前后都是骨干、核心开发，因为我负责的系统多，11个，也都是平台核心系统，比如支付、存管，这些当中大部分也都是我一个人在负责，最新研发的区块链存证系统也是我独立研发的。 加上最近架构调整，部门去年计划把我提成室经理，过去的这半年多已经让我带一个框架研发团队了，既负责团队管理，还要兼顾系统设计和开发和运维，我们团队是人最少的，负责系统最多的，而且未来负责的系统会更多，我觉得我为单位做的贡献是远大于上次调薪的比例的。 结合市场行情我相信目前同级别的同事里我的工资应该是算最低的，但是相比我做的事是最多的。这点我们整个部门都是认可的。\n因为目前的级别是高级后台开发和架构师。 来咱们公司差四个月满3年了，上个月调薪是来咱们公司之后第一次调，整体的薪资规划和我计划的是差很多的，我媳妇刚怀了宝宝，并且换了房子，压力比较大，目前的薪资水平会很大方面影响我的工作 我希望调薪的最终目标是总包最低43，这个目标不是随口说的，因为公司离职的前同事里边，内推我的特别多。 按照上一年的薪酬和年终奖，我拿到的总计时30。我觉得我的要求不算过分。\n我觉得无论是咱们公司还是其它公司，肯定是能者既多劳也多得！而且不论是什么情况，我都会站好我这一班岗，因为作为员工来说，做好了自然能证明自己。做不好也没资格提什么要求，我们也都理解。\n要放松、自信且尊重\n整体谈判态度：放松、自信且尊重\n姓名：胡丁武 入职时间：差四个月满3年 岗位和职责：在金科和惠金所合并前后都是骨干、核心开发 当前工作：负责的系统多，11个，都是平台核心系统，比如支付、存管，这些当中大部分也都是我一个人在负责，部门最新研发的区 块链存证系统也是我独立研发 后续工作重心：最近架构调整，部门去年计划把我提成室经理，让我带一个框架研发团队（核心团队，人少），这半年多既负责团队 管理，还要兼顾系统设计和开发和运维，目前直接负责系统最多，未来系统会更多 部门的定位：相比相同职位的同事，我做的事是最多的，我为单位做的贡献是受整个部门认可的。 级别：目前的级别是高级后台开发和架构师 薪资规划：上个月调薪是来咱们公司之后第一次调，整体的薪资规划和我计划的是差很多的 家庭：我媳妇刚怀了宝宝，并且换了房子，压力比较大，目前的薪资水平会很大方面影响我的工作 目标和期望：我希望调薪的最终目标是总包最低43 offer方面：这个目标不是随口说的，因为公司离职的前同事里边，内推我的特别多。 调薪合理性：按照上一年的薪酬和年终奖，我拿到的总计时30。我觉得我的要求不算过分。 工作态度：我觉得无论是咱们公司还是其它公司，肯定是能者既多劳也多得！而且不论是什么情况，我都会站好我这一班岗，因为作 为员工来说，做好了自然能证明自己。做不好也没资格提什么要求，我们也都理解。\n谈判主导方向 谈判要点 最后的筹码 最后的底线  ","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E5%90%91hr%E6%8F%90%E5%87%BA%E5%90%88%E7%90%86%E7%9A%84%E6%B6%A8%E8%96%AA%E8%A6%81%E6%B1%82/","series":[],"tags":["HR","涨薪"],"title":"如何向HR提出合理的涨薪要求.md"},{"categories":["设计模式"],"content":" https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==\u0026amp;mid=2247516612\u0026amp;idx=1\u0026amp;sn=da8d528697a15722e3aa53986aa3aada\u0026amp;chksm=fa4afe75cd3d7763d367929411ff0affca05b71ab827148b2cb7d6dbbb88b33bc76fa3d5a4a4\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0525GBDcNZ5yv9lgXOrcNzj4\u0026amp;sharer_sharetime=1621911183717\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n廖雪峰的java教程中对java设计模式讲的特别好，通俗易懂 https://www.liaoxuefeng.com/wiki/1252599548343744/1264742167474528\n","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E5%85%A8%E9%83%A8%E6%90%9E%E6%87%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","series":[],"tags":[],"title":"如何全部搞懂设计模式.md"},{"categories":["分布式"],"content":" https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==\u0026amp;mid=2651968036\u0026amp;idx=2\u0026amp;sn=0e3b26a3fc7a46785433eed013e8907b\u0026amp;chksm=bd2d67f88a5aeeee6104fa43f8b78ac62aa7267633e3d14101733835189f44b42c8586bba204\u0026amp;mpshare=1\u0026amp;scene=1\u0026amp;srcid=0617HHC4h4WvvkqalGv1uQcA\u0026amp;sharer_sharetime=1623935878168\u0026amp;sharer_shareid=cbc82124cedc2b0864b983af90cce39a#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%A6%82%E4%BD%95%E6%8A%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%AE%B2%E6%B8%85%E6%A5%9A/","series":[],"tags":["分布式事务"],"title":"如何把分布式事务讲清楚.md"},{"categories":["职业规划"],"content":"  技术性岗位可以向管理岗位转，反过来则不成立，老不碰代码，代码能力就下降了。 裁员浪潮中，首当其冲的就是纯管理，技术人员再找工作比纯管理好。管理的成果可能产生于大环境和所在公司，体现不了你自己本身的价值。 技术才是保命的本领。  ","date":"2021-06-29","permalink":"/posts/notes/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E8%BD%AC%E5%8F%98%E7%AE%A1%E7%90%86%E5%B2%97/","series":[],"tags":["程序员","技术管理"],"title":"程序员是否应该转变管理岗.md"},{"categories":["Java"],"content":" https://blog.csdn.net/andy_67/article/details/84837804 https://blog.csdn.net/user2025/article/details/106039999?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control\u0026amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control https://blog.csdn.net/Dongguabai/article/details/80788585 https://mp.weixin.qq.com/s?__biz=MzU1OTgyMDc3Mg==\u0026amp;mid=2247483911\u0026amp;idx=1\u0026amp;sn=f6d3fbd8ca0f09bc0ee4cf346bc4e862\u0026amp;chksm=fc10388ccb67b19ac3042fbc8ea3f1cce035172fb46651a86f351eb915751547440eb8edee72\u0026amp;token=336585355\u0026amp;lang=zh_CN#rd%20https://mp.weixin.qq.com/s?__biz=MzU1OTgyMDc3Mg==\u0026amp;mid=2247483918\u0026amp;idx=1\u0026amp;sn=60b22f9555eefb2e5e0c4b88f5be3003\u0026amp;chksm=fc103885cb67b1930e2715f0cfd7fde3fc35732caa4d37fe0492da56876209a9ed45a61d0e4a\u0026amp;token=336585355\u0026amp;lang=zh_CN#rd\n","date":"2021-06-29","permalink":"/posts/notes/%E5%89%96%E6%9E%90%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","series":[],"tags":["动态代理","CGLIB","Spring"],"title":"剖析动态代理.md"},{"categories":["mysql"],"content":"EasyExcel的使用 ","date":"2021-06-29","permalink":"/posts/notes/%E5%AF%B9%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E6%A0%B8%E9%AA%8C%E5%B9%B6%E6%9B%B4%E6%96%B0%E7%9A%84demo/","series":[],"tags":["excel","easyexcel"],"title":"对批量数据核验并更新的demo"},{"categories":"iOS cer p12","content":"理解iOS开发证书 术语解释 cer 一种文件格式，存储的是公钥，学名证书\n如何生成cer  der二进制编码（cer有别于ber、der） base64编码  der 二进制格式，不可读，Java和Windows服务器偏向使用这种格式 DER格式的证书基于X.509标准\nPKCS#12 一个公钥加密的标准，总共有15个\np12 .p12是基于PKCS#12标准生成的一种文件格式，存储的是私钥 mac系统下在keychains钥匙串中找到证书-\u0026gt;导出-\u0026gt;p12就可以\n数字证书 无论是cer还是p12，广义上说都可以被称为数字证书。 | 什么是数字证书呢？数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（CertificateAuthority）中心发行的，人们可以在网上用它来识别对方的身份。在当今这个互联网时代，已经成为了必不可少，不可或缺的一个过程。\n PEM pem文件是p12文件转换后的一种文件格式，存储的也是密码（私钥还是公钥？），内容是BASE64编码 以\u0026mdash;\u0026ndash;BEGIN开头，\u0026mdash;\u0026ndash;END结束 Apache和Linux、Unix服务器偏向使用这种编码格式 PEM格式的证书基于X.509标准\nHttps和Http关于s的区别以及SSL OpenSSL 是SSL规范的一种实现。它还提供了一些工具软件，SSL证书需要符合的是一种标准X.509、RFC5280\n证书编码格式的问题 证书编码格式常见的有pem和der，但是文件扩展名并一定就是它俩，证书可以转换为其它编码格式，内容也有差别\n证书格式  CRT CER KEY PFX/p12 JKS  CSR Certificate Signing Request, 证书签名请求，用户生成公私钥，私钥自己保存好，公钥作为申请内容，向证书颁发机构申请获得签名证书\niOS证书申请、到发布、再到用户安装过程中的流程 ![]({{ site.baseurl }}/images/apple_auth_process.png)\n","date":"2020-01-16","permalink":"/posts/notes/2020-01-16-ios-develop-certificate-understanding/","series":null,"tags":null,"title":"ios develop certificate understanding"},{"categories":"fabric","content":"charactoristics on hyperledger fabric 一个标准的可认为是最佳实践的fabric项目应当具备的特性   初始配置\n  各组件启动\n  通道创建和加入\n  链码的注册和实例化\n  界面化的demo演示交易的调用\n  blockchain explorer启动和查看运行、网络、区块、交易\n  demo应用监听事件\n  多级证书配置和可插拔\n  动态加入和撤出组织\n  更换排序共识插件\n  组件无限扩展\n  账本、状态的存储结构替换\n  多通道\n   ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-charactoristics-on-hyperledger-fabric/","series":null,"tags":null,"title":"charactoristics on hyperledger fabric"},{"categories":"AST","content":"抽象语法树AST https://baijiahao.baidu.com/s?id=1626159656211187310\u0026amp;wfr=spider\u0026amp;for=pc\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-ast/","series":null,"tags":null,"title":"learn ast"},{"categories":"flow","content":"design a flow based develop and invoke system todo cabala重构点： 根据接口查脚本 根据脚本反查接口\n脚本写完模拟调用 接口写完模拟调用\n管理页面提取成一套，根据接口名称和脚本名称查询 搜索规则有：list，count，save，get，edit，remove，其它\n业务模块-\u0026gt;接口 -\u0026gt;脚本(脚本中指定库)\n开始结束 循环、判断 数据库操作 缓存操作\n调用子服务 同步和异步\n从原始接口表更新到目标接口表：指定接口号和脚本代码即可，自动拉取同步，自动刷新缓存，永不重启引擎服务\n开启提示模式时，节点入出的参数都展示出来\n判断、循环的代码段可以边编辑边拷贝参考\n接口流程图直接生成一个单独文件，并保存至文件服务器\n接口流程图可以映射到文档文件，文档文件可以直接生成接口流程图\n接口流程图有专门的查看搜索等管理，选择环境可以查看，各节点全部展示出出入参\n接口可以导入导出流程图\n每天自动把节点\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-design-a-flow-based-develop-and-invoke-system/","series":null,"tags":null,"title":"design a flow based develop and invoke system"},{"categories":"shell","content":"learn shell from start 打印日期的两种方式 echo today is `date \u0026#34;+%Y-%m-%d\u0026#34;` echo today is $(date \u0026#34;+%Y-%m-%d\u0026#34;) shell中变量的使用 mypid=$$ echo \u0026ldquo;mypid:$mypid\u0026rdquo;\nparamCount=$# echo \u0026ldquo;paramCount:$paramCount\u0026rdquo;\nlastPid=$! echo \u0026ldquo;lastPid:$lastPid\u0026rdquo;\nlastResponse=$? echo \u0026ldquo;lastResponse:$lastResponse\u0026rdquo;\nsetFlag=$- echo \u0026ldquo;setFlag:$setFlag\u0026rdquo;\nparams=$* echo \u0026ldquo;params:$params\u0026rdquo;\nstringParams=$@ echo \u0026ldquo;stringParams:$params\u0026rdquo;\nparam0=$0 echo \u0026ldquo;param0:$param0\u0026rdquo;\nparam1=$1 echo \u0026ldquo;param1:$param1\u0026rdquo; printf \u0026ldquo;param1 is %s\\n\u0026rdquo; $param1\nfor i in $@; do echo $i done\nfor i in $params; do echo $i done\n`` 和 $() 里面的都是命令 echo Linux echo Shell echo today is date \u0026quot;+%Y-%m-%d\u0026quot;``` echo Linux echo Shell $(echo today is $(date \u0026ldquo;+%Y-%m-%d\u0026rdquo;))` echo Linux $(echo Shell $(echo today is $(date \u0026ldquo;+%Y-%m-%d\u0026rdquo;)))\n${}里面的是变量 A=Charlie echo \u0026ldquo;variable AB is: $AB\u0026rdquo; echo \u0026ldquo;variable A($A) concat charactor B is: ${A}B\u0026rdquo;\nfile=/Users/huray/Desktop/testshell.sh\n#是去掉左边(在键盘上 # 在 $ 之左边) % 是去掉右边(在键盘上 % 在 $ 之右边) 单一符号是最小匹配;两个符号是最大匹配 *是用来匹配不要的字符，也就是想要去掉的那部分 还有指定字符分隔号，与*配合，决定取哪部分 拿掉第一条 / 及其左边的字符串 echo ${file#*/}\n拿掉最后一条 / 及其左边的字符串 echo ${file##*/}\n拿掉第一个 . 及其左边的字符串 echo ${file#*.}\n拿掉最后一个 . 及其左边的字符串 echo ${file##*.}\n拿掉最后一条 / 及其右边的字符串 echo ${file%/*}\n拿掉第一条 / 及其右边的字符串 echo ${file%%/*}\n拿掉最后一个 . 及其右边的字符串 echo ${file%.*}\n拿掉第一个 . 及其右边的字符串 echo ${file%%.*}\n参考文档 https://www.cnblogs.com/chengd/p/7803664.html\n目录和路径的获取 https://blog.csdn.net/Jerry_1126/article/details/79872110\n循环 for((paramIdx=1; paramIdx\u0026lt;10; paramIdx++)); do eachParam=$paramIdx echo \u0026ldquo;eachparam:$eachParam\u0026rdquo; done pcount=$# if ((pcount==0)); then echo no args; exit; fi  #2 获取文件名称 p1=$1 fname=basename $p1  echo $fname  #3 获取上级目录到绝对路径 pdir=cd -P $(dirname $p1); pwd echo $pdir  #4 获取当前用户名称 user=whoami  #5 循环 for((host=1; host\u0026lt;4; host++)); do echo \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- hadoopnode0$host \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; rsync -av $pdir/$fname $user@hadoopnode0$host:$pdir done ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-shell-from-start/","series":null,"tags":null,"title":"learn shell from start"},{"categories":"algorithms","content":"byzantine：拜占庭问题的算法 https://www.zhihu.com/question/30288330\n1.5（P - E） \u0026gt; P 3 / 2 * P - 3 / 2 * E \u0026gt; P 1 / 2 * P \u0026gt; 3 / 2 * E P \u0026gt; 3 E 1 / 3 * P \u0026gt; E\n如果系统中有n个故障节点，系统要想正确运行，必须至少要有2n+1个正常节点\nP = N + E N \u0026gt; X \u0026gt; N/2 + E\n1.5N \u0026gt; N + E\n1 / 2 N \u0026gt; E N \u0026gt; 2E\n所有正确的节点最终会决定一个值（termination） 所有正确的节点决定的值必须相同（agreement） 所有正确的节点决定的值必须是被正确的节点提出来的（validity）\n消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的\n安全的互相传递消息的前提下，一个忠臣提出的意见和其它忠臣的意见都相同，最终所有忠臣都同意这个意见。 我们要确定的就是需要最少几个忠臣。 分布式网络下需要最少几个正确节点\n延伸问题 ProofOfWork ProofOfStake 比特币、以太坊等的共识算法\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-byzantine/","series":null,"tags":null,"title":"byzantine"},{"categories":"distributed","content":"distributed system learn key point ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-distributed-system-learn-key-point/","series":null,"tags":null,"title":"distributed system learn key point"},{"categories":"maven","content":"maven project directory standard ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-maven-project-directory-standard/","series":null,"tags":null,"title":"maven project directory standard"},{"categories":"Java","content":"parse request url ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-parse-request-url/","series":null,"tags":null,"title":"parse request url"},{"categories":"linux","content":"CentOS7关闭SELinux [root@dev-server ~]# getenforce Disabled [root@dev-server ~]# /usr/sbin/sestatus SELinux status: disabled # 永久关闭 vi /etc/selinux/config # 将SELINUX=enforcing改为SELINUX=disabled # 重启后生效 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-linux-close-selinux/","series":null,"tags":null,"title":"linux close selinux"},{"categories":"linux","content":"centOS7永久关闭防火墙 # 查看状态 systemctl status firewalld.service # 关闭 systemctl stop firewalld.service # 开机禁用 systemctl disable firewalld.service # 开启 systemctl start firewalld.service # 开机启用 systemctl enable firewalld.service ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-operate-linux-firewall/","series":null,"tags":null,"title":"operate linux firewall"},{"categories":"orm","content":"learn hibernate mybatis and orm todo hibernate mybatis ORM\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-hibernate-mybatis-and-orm/","series":null,"tags":null,"title":"learn hibernate mybatis and orm"},{"categories":"database","content":"数据库设计的原则 简单记录几点要点  符合业务需求 避免冗余  数据仓库设计要以哪些指标为主？  需求 维度 指标  数据库的需求和数据仓库需求的不同  数据库要求的是实时，一致 数据仓库要求的是汇总数据有效，全量，不需实时  数据仓库产生的因素 数据仓库产生于数据库之上，为了进一步挖掘数据资源、决策需要而存在\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-database-design/","series":null,"tags":null,"title":"database design"},{"categories":"mysql","content":"derby and mysql todo derby 哪些方面能代替mysql MariaDB 为什么是mysql的分支 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-derby-and-mysql/","series":null,"tags":null,"title":"derby and mysql"},{"categories":"linux","content":"查询linux中各种状态的tcp连接 netstat -ant |grep CLOSE_WAIT|wc -l 同理可替换CLOSE_WAIT为  TIME_WAIT ESTABLISHED  ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-query-linux-tcp-exceptional-tcp-connections/","series":null,"tags":null,"title":"query linux tcp exceptional tcp connections"},{"categories":"Java","content":"Array和ArrayList的各自特点和区别 Array  内存中是连续的 读取和赋值很快 扩容和收缩很慢 需要指定内存大小  ArrayList  不需要指定容量 方便动态扩容和收缩 可以保存不同类型，本质都当作Object处理 ArrayList不是类型安全，需要拆装箱 通过指定泛型，通过编译来强制使用正确统一的数据类型，也减少了类型转换  ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-difference-from-array-and-arraylist/","series":null,"tags":null,"title":"difference from array and arraylist"},{"categories":"mysql","content":"清楚重复数据 建表 CREATE TABLE `src5` ( `userid` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(20) DEFAULT NULL, `usercode` varchar(20) DEFAULT NULL, PRIMARY KEY (`userid`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; 如果usercode重复，那么可能会出现以下数据 userid username usercode 1 \u0026hellip; code0 2 \u0026hellip; code0 3 \u0026hellip; code0\n删除id最大的那一行，比如删除code0，userid为3的那行 DELETE FROM src5 WHERE userid IN ( SELECT id FROM ( SELECT MAX(userid) AS id, COUNT(usercode) AS ucount FROM src5 GROUP BY usercode HAVING ucount \u0026gt; 1 ORDER BY ucount DESC ) tab ) 如果没有自增主键，需要先临时增加，以tmpid为count ALTER TABLE src5 ADD COLUMN tmpid INT(11) PRIMARY KEY AUTO_INCREMENT; 最后再删除 ALTER TABLE src5 DROP COLUMN tmpid; 同时修改原来的主键column ALTER table table_name add PRIMARY KEY (user_role_id) ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-delete-dirty-lines-in-mysql/","series":null,"tags":null,"title":"delete dirty lines in mysql"},{"categories":"resume","content":"写好一份技术简历的要点 几个注意点  框架是重点，但别让人感觉你只会山寨别人的代码 别单纯看单机版的框架，适当了解些分布式 数据库方面，别就知道增删改查，得了解性能优化，NoSQL亦如此 Java核心方面，围绕数据结构和性能优化准备面试题 Linux方面，至少了解如何看日志排查问题 通读一些底层代码，作为加分项  一切的一切，把上述技能嵌入到你做过的项目里 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-how-to-descripe-in-resume/","series":null,"tags":null,"title":"how to descripe in resume"},{"categories":"work","content":"write work summary 总结中必须包含的几大内容点  工作中暴露问题 某些方案提出合理的方案 自己工作中的提升 对来年的展望 未来公司的规划、个人的规划  工作总结要可以体现出以下特点  精确 准确、量化 对公司核心的作用 工作重要性的排列 可以借鉴给他人复用的工作经验 必要的反思 来年工作计划、思考、体现出热情  其它补充的点  应当适当表明成功来源于领导 征求领导的建议 不告状 *不带情绪  ","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-write-work-summary/","series":null,"tags":null,"title":"write work summary"},{"categories":"shell","content":"how to post by shell 本篇文章留存，用作帮助使用shell去快速发布一篇文章\n","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-how-to-post-by-shell/","series":null,"tags":null,"title":"how to post by shell"},{"categories":"shell","content":"how to auto publish post 我这里使用的是zsh\n#!/bin/zsh ","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-how-to-auto-publish-post/","series":null,"tags":null,"title":"how to auto publish post"},{"categories":"english","content":"转载   This approach has several drawbacks for users. Therefore, before considering this approach, make sure that it will not negatively impact the user experience.  ","date":"2019-10-28","permalink":"/posts/notes/2019-10-28-sentences-each-day/","series":null,"tags":null,"title":"sentences each day"},{"categories":"nginx","content":"转载  vim /usr/local/etc/nginx/nginx.conf sudo nginx -s reload ","date":"2019-10-28","permalink":"/posts/notes/2019-10-28-shortcuts-for-nginx/","series":null,"tags":null,"title":"shortcuts for nginx"},{"categories":"sh","content":"转载 scp scp /data/somefile.sometype tomcat@destinationhost:/data/newfile.type tar press:\ntar czf result.tar.gz sourcefile/ unpress:\ntar xzf result.tar.gz sourcefile/ ","date":"2019-10-21","permalink":"/posts/notes/2019-10-21-how-to-use-scp-and-tar/","series":null,"tags":null,"title":"how to use scp and tar"},{"categories":"sh","content":"转载 guideline https://zhuanlan.zhihu.com/p/37195261\ndylib error https://discourse.brew.sh/t/library-not-loaded-usr-local-opt-gdbm-lib-libgdbm-4-dylib/2647/5\n","date":"2019-10-10","permalink":"/posts/notes/2019-10-10-use-iterm2-and-oh-my-zsh-to-replace-terminal/","series":null,"tags":null,"title":"use iterm2 and oh-my-zsh to replace terminal"},{"categories":"jdk","content":" 示例 # 查看flutter环境 flutter doctor # 升级flutter flutter upgrade # 查看flutter版本分支 flutter channels ","date":"2019-08-09","permalink":"/posts/notes/2019-07-30-how-to-install-flutter-on-mac/","series":null,"tags":null,"title":"how to install flutter on mac"},{"categories":"jdk","content":"AbstractQueuedSynchronizer Lock 使用Lock接口是java实现锁的一种方式。 Lock接口在java.util.concurrent.locks包下。 ReentrantLock(可重入锁)、ReadLock(读锁)、WriteLock(写锁)是Lock接口最重要的三个实现类。 ReadWriteLock接口是一个工厂接口，ReentrantReadWriteLock是ReadWriteLock接口的实现类，它包含两个内部静态类ReadLock(读锁)、WriteLock(写锁)，这两个静态类又分别实现了Lock接口。\n悲观锁与乐观锁的定义 它们是在并发情况下的两种不同策略。java中没有明确的类就是乐观锁或者悲观锁。\n  悲观锁的策略： 就是很悲观，认为每次去拿的数据可能被别人修改过了。所以，自己去拿数据的时候会上锁，导致别人等到锁被释放才能获取数据。\n  乐观锁的策略： 每次去拿数据的时候认为别人不会修改，不上锁。 只是在更新的时候采用一种特殊方式，因为更新分为三步，先读取、然后检查、最后更新；所以在更新之前要先检查读取的数据是不是已经被别人修过过了。如果修改过了，就重新读取，再次重复检查步骤最后更新。 有的情况下，更新失败的所在的线程可能会放弃操作。\n  比较 所以说 悲观锁阻塞事务，乐观锁回滚重试。\n  对于写少的情况，即冲突少，采用乐观锁，可以省去锁的开销，增加数据系统的吞吐量。 如果冲突多，不断地回滚重试反倒是降低性能，不如采用悲观锁合适。\n乐观锁的回滚重试 通常把这种策略用概念CAS表示：Compare-and-swap\n","date":"2019-08-09","permalink":"/posts/notes/2019-08-09-abstract-queued-synchronizer/","series":null,"tags":null,"title":"AbstractQueuedSynchronizer"},{"categories":"jdk","content":"Mac下查看已安装的jdk版本及其安装目录 示例 /usr/libexec/java_home -V ","date":"2019-07-30","permalink":"/posts/notes/2019-07-30-find-java-path/","series":null,"tags":null,"title":"find java path"},{"categories":"math","content":"https://zhuanlan.zhihu.com/p/48307582\n如何证明π为常数？ \u0026ndash;为什么π是一个常数？即为什么所有圆的周长和直径之比为一个定值？\n解答： 小圆的半径r1，周长c1；大圆的半径r2，周长c2 小圆内切正n边形，边长为k1；大圆内切正n边形，边长为k2 OA:OD=OB:OC；角AOB = 角COD；三角形OAB全等于三角形OCD ∴ k1:r1=k2:r2 设小正n边形周长为c1',大正n边形周长为c2' c1'=nk1,c2'=nk2 c1':r1=c2':r2 当n等于无限大时，c1'=c1,c2'=c2 ∴ c1:r1=c2:r2\n所以，对于半径不同的圆，各自周长除以半径为定值（常数），记该常数为2π， 则周长除以直径为π 证明π为常数\n","date":"2019-07-24","permalink":"/posts/notes/2019-07-24-how-to-prove-pi/","series":null,"tags":null,"title":"how to prove pi"},{"categories":["mysql"],"content":"MySQL SQL GROUP BY是如何选择哪一条数据留下的 示例 -- 建表 CREATE TABLE `src2` ( `id` int(11) DEFAULT NULL, `name` varchar(20) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 查询 SELECT id, name FROM src2; 查询到的结果 id name 1 alpha 1 bravo 2 charlie 2 dolphin\n查看当前mysql版本，并且看是否开启了only full group by SELECT version(), @@sql_mode; 5.7.20 STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n根据id使用group by查询id,name SELECT id, NAME FROM src2 GROUP BY id; 如无异常会查询到两条数据，但是同样为id1的两条数据是如何选择留哪一条呢 1 alpha 2 charlie\n稍后再看，先解决这个问题 关闭only full group by -- 去除 SET sql_mode=(SELECT REPLACE(@@sql_mode,\u0026#39;ONLY_FULL_GROUP_BY\u0026#39;,\u0026#39;\u0026#39;)); -- 再次查询 SELECT version(), @@sql_mode; 如何恢复？ 5.7之前的mysql其实是处于未定义规则状态，官方文档不承诺一定会返回哪条数据。而到了MySQL5.7，仍然是未定义状态，并且默认直接不允许未定义状态的grouping查询，会报错：\nExpression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'learn.src2.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by -- 重新开启only full group by SET sql_mode=(SELECT CONCAT(@@sql_mode, \u0026#39;,ONLY_FULL_GROUP_BY\u0026#39;)); 那么查询的重复id的数据应该返回哪一条呢 要看查询具体使用的b-tree索引中第一个命中的数据。\n如何优化或者改变查询方式 -- 加入max条件或者其它 SELECT * FROM src2 WHERE NAME IN (SELECT max(NAME) FROM src2 GROUP BY id) ORDER BY id ASC 参考mysql文档： group by handling ","date":"2019-07-10","permalink":"/posts/notes/2019-07-10-mysql-only-full-group-by/","series":["MySQL由浅入深"],"tags":["语法"],"title":"mysql only full group by"},{"categories":"encrypt","content":"在mysql中对字符串aes加密和解密 直接上函数 # 加密 SELECT HEX(AES_ENCRYPT(\u0026#39;123456\u0026#39;,\u0026#39;root\u0026#39;)) # 解密 SELECT AES_DECRYPT(unhex(\u0026#39;537AB41AAABDEC3BAB09BE15392B916A\u0026#39;), \u0026#39;root\u0026#39;) ","date":"2019-07-10","permalink":"/posts/notes/2019-07-10-aes-encrypt-in-mysql/","series":null,"tags":null,"title":"aes encrypt in mysql"},{"categories":"linux","content":"centos搭建docker私有仓库 安装docker 略过\n# 重启docker systemctl daemon-reload systemctl restart docker 拉取仓库镜像 docker pull registry 运行仓库 docker run -d -v /registry:/var/lib/registry -p 5000:5000 --restart=always --privileged=true --name registry registry:latest 示例:从官方仓库拉取hello-world docker pull hello-world 给hello-world镜像打个tag，表示新的版本 docker tag hello-world 127.0.0.1:5000/hello-world:latest 推送：将新的hello-world镜像上传到私有仓库 docker push 127.0.0.1:5000/hello-world:latest 在私有仓库查看上传的镜像 ls /registry/docker/registry/v2/repositories 通过客户端查看镜像\ncurl http://127.0.0.1:5000/v2/_catalog 输出:\n{\u0026#34;repositories\u0026#34;:[\u0026#34;hello-world\u0026#34;]} ","date":"2019-06-28","permalink":"/posts/notes/2019-06-28-install-docker-registry-on-centos/","series":null,"tags":null,"title":"install docker registry on centos"},{"categories":"jekyll update","content":"如何在mac上安装jykell\n1.安装rvm\ncurl -L get.rvm.io | bash -s stable source ~/.rvm/scripts/rvm rvm -v  2.安装ruby\nrvm install 2.6.0 rvm list  3.安装jykell\ngem source gem install jekyll jekyll -version  4.安装bundle\ngem install bundle 运行bundle，安装Gemfile里的插件 bundle install  5.初始化web项目\njekyll new r2ys-site cd r2ys-site/  6.本地localhost:4000测试\njekyll serve jekyll serve --watch --baseurl '/blog'  7.内容生成\njekyll build  You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.\nTo add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.\nJekyll also offers powerful support for code snippets:\n{% highlight java %} System.out.prinln(\u0026quot;\u0026quot;); def print_hi(name) puts \u0026ldquo;Hi, #{name}\u0026rdquo; end print_hi(\u0026lsquo;Tom\u0026rsquo;) #=\u0026gt; prints \u0026lsquo;Hi, Tom\u0026rsquo; to STDOUT. {% endhighlight %}\n{% highlight oc %} NSString *str = @\u0026ldquo;suck\u0026rdquo;; {% endhighlight %}\n![avatar]({{ site.baseurl }}/assets/201812121137485b3b6458f4023.jpg)\nCheck out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo . If you have questions, you can ask them on Jekyll Talk .\n","date":"2019-01-08","permalink":"/posts/notes/2019-01-08-how-to-install-jykell-on-mac/","series":null,"tags":null,"title":"How to install jykell on mac!"},{"categories":null,"content":"","date":"0001-01-01","permalink":"/posts/notes/2020-01-14-%E5%A6%82%E4%BD%95-%E4%BD%BF%E7%94%A8-jekyll/","series":null,"tags":null,"title":""},{"categories":null,"content":" 拜占庭容错 崩溃容错   ","date":"0001-01-01","permalink":"/posts/notes/fabric_%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":""},{"categories":null,"content":"IoC ","date":"0001-01-01","permalink":"/posts/notes/ioc/","series":null,"tags":null,"title":""},{"categories":null,"content":"Java动态代理 ","date":"0001-01-01","permalink":"/posts/notes/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","series":null,"tags":null,"title":""},{"categories":null,"content":"Spring如何解决循环依赖的 三级缓存 @Lazy ","date":"0001-01-01","permalink":"/posts/notes/spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84/","series":null,"tags":null,"title":""},{"categories":null,"content":"兑换码/序列号生成 需求  16位字符串，包含数字或字母 随机性，无法猜测和暴力碰撞 永不重复  分析  给定的要求是永不重复，但往往业务的体量不同，上限也不同；假定单个业务类型下可支持的总量为1亿，技术上能实现10亿是否就能满足需求？ 数字或字母，参考以往Base32编码表中字母为A-Z共26个，数字为234567，去掉了容易混淆的0、1、8、9；32个字符随机是否也能满足需求？  生成流程    生成原理 先逆向考虑\n32个字符的编码表最多表示多少个数？\n1个字符能表示32个数：0,1,2,\u0026hellip;,30,31对应A,B,C,\u0026hellip;,6,7\n2个字符能表示1024个数: 0,1,2,\u0026hellip;,30,31,32,33,34,\u0026hellip;,1022,1023对应A,B,C,\u0026hellip;,6,7,AB,AC,AD,\u0026hellip;,ZX,ZY\n结论：1个字符表示32^1个数；2个字符表示32^2个数\n那么32个字符表示32^32个数，约为1.4e48，支持10^40个亿。\n16位字符能表示的最多有32^16个数，约为1.2e24，10^16个亿，肯定能包含在32字符编码所支持的范围，也自然远超过需求的1亿个数，我们以技术能支持的上限10亿作为目标。\n接下来，怎么表示这10亿个数，用字符串、浮点、整型肯定是不理想的，我们选择用bit来表示，java中byte字节是8个bit：\n1bit能表示2^1个数，以int32位无符号整数举例，32bit能表示2^32个数，float64bit能表示2^64个数\n所以log2(10亿)能表示10亿个数，也就是29.897353bit能表示10亿个数，约为30bit。\nlog2(32^16)能表示10^16亿个数，约为80bit。\n我们使用超过30bit的值来表示这10亿个数即可，那么如何确定bit使用多少位？用bit表示的值怎么转换成16位字符？\n我们计划使用Base32编码表中的编码来表示最终的16位字符，Base32的转换方式是这样的，每5bit作为一个小节，5bit有2^5也就是32种情况，每种情况对应一个0-31的数值，根据下标也就能对应一个编码。\n举例如下：\n// 字节数组byte[]中存放了2个byte字节也就是16bit的short类型的数据：127 127 // 对应二进制表示为：01111111 01111111 // 将二进制作5位一个小节的拆分：01111 11101 11111 1base32中的编码表是： // 末位不够5位的后边补0: 01111 11101 11111 10000 // 对应的数值就是：15 29 31 16 // base32中的编码表是：ABCDEFGHIJKLMNOPQRSTUVWXYZ234567 // 所以对应的下标：15:P 29:5 31:7 16:Q // 将byte[(byte)127,(byte)127]进行base32编码的结果是：P57Q 回到刚才的问题，如何确定bit使用多少位？用bit表示的值怎么转换成16位字符？\n用base32可以将76-80bit的数值转换成16位字符；根据最终序列号长度n的要求，使用(5(n-1),5n]来表示bit位数。\njava以uff-8编码的数据类型中，byte8bit、short16bit、int32bit、long64bit、英文数字字符char8bit、中文字符char24bit。\n为了实现16位序列号，bit总长度为80bit，数值长度需要\u0026gt;30bit，有两种选择，int32bit和long64bit，但因为我们考虑加一些payload、sign，选择int32bit即可，为其它位置预留空间。payload包含一些标记字段，如发行信息、序列号扩展信息、发行时间等。sign可以将payload和data合并之后的bit作哈希签名，方便客户端或者服务端的简单校验。\n在此基础上，假定规划如下：\npayload(32bit)+data(32bit)+sign(16bit)\n  payload：使用长度为4字节的int，这里将业务应用的模版编号在数据库中的自增主键拿过来用，通常自增主键是bigint(8字节，能存2^64个整数)或int(4字节，能存2^32个整数，约40亿)，在字符串长度可以增加的情况下我们可以选择bigint，这里我们采用int作为payload中的模版编号。\n  data: 使用长度为4字节的int\n  sign: 将payload+data整体64bit作hash摘要，然后取余:%16，结果是2字节的sign\n  所以，如果是模版编号0，第一次获取的序列号用十进制数据表示为：\n0 0 \u0026lsquo;7X\u0026rsquo;\n对应二进制：\n00000000000000000000000000000000 00000000000000000000000000000000 00000111 01011000\n接下来，\n采用base32，需要被base编码最大bit位数5和数据存储最小位数8整除\n16个字符(80bit)：payload(32bit)+data(32bit)+sign(16bit)\n24个字符(120bit)：payload(32bit)+data(64bit)+sign(24bit)\n32个字符(160bit)：payload(64bit)+data(64bit)+sign(32bit)\n10 12 15 16 20 24 25\n50 60 75 80 100 120 125\n32 32 64 64 64 64 64\n18 28 11 16 36 56 61\n8^2 8^3 8^1 8^1 8^4 8^7 8^7\n2 4 3\t0\t4\t0\t5\n24\n1 固定256bits的密钥K、64bits的新鲜值N\n2 将序号i与K还有N一起使用chacha20算法计算出512bits的伪随机数R\n3 将R拆分成256bits的R1和R2，R1是hmac的salt，(i+payload+R2)作为明文，得到摘要H\n4 将payload和摘要H拼接并截取前30bit，与R2的前30bits做异或，得到密文C\n5 将i和c拼接组成59bits，使用base24算法转译\n 输入参数为店铺编号、卡号、序号 用ChaCha20算法对序号加密，得到一个512字节的随机数 将步骤2生成的随机数取前256字节作为HMAC算法的密钥 将序号、店铺编号、步骤2生成的随机数的后256字节拼成字节数组 用步骤3生成的HMAC对步骤4生成的字节数组进行加密 将店铺编号编码为27bit，步骤5生成的字节数组取前18bit，拼成45bit报文 步骤4生成的字节数组取前45bit报文M1，步骤6生成的45bit报文M2，将M1和M2进行异或运算 根据序号得到30bit的明文，步骤7得到45bit密文，将明文和密文拼接成75bit的激活码主体 用ChaCha20算法对卡号进行加密，得到的随机数按字节求和，然后对32取模 根据步骤9的结果，得到一套base32的编码方式，对步骤8产生的75bit激活码主体进行编码，得到15位的32进制数（大写字母和数字，排除掉0O1I） 步骤9得到的结果进行base32编码得到一位32进制数 将步骤11和步骤10得到的结果拼在一起，得到16位的激活码  1个字符能表示33个数：34^1-1=33 2个字符能表示1155个数：34^2-1=1155 16个字符能表示(34^16-1)个数 16个字符对应二进制数是81bit：log2(34^16-1) 需求上限如果是4亿个数，对应的二进制数是29bit: log2(4亿) 二进制数是29bit，选择使用32bit，正好是十进制int 那么16个字符一定能满足，而且只会占用极小部分\nint32位无符号整数可以表示的数有(2^32-1)个：4294967295，约为42.9亿个数 需求按4亿，我们能满足40亿 最大值为:11111111111111111111111111111111 最小值为:00000000000000000000000000000000\n既然16个字符能表示81位，那我们可以将一些标记、校验补充进去 假定分割的bit如下： 9位(用来存放一些payload)+64位(用来存放递增数据)+6位(用来字符校验) 64位用来存储数据，但是是加密后的数据，我们采用加密算法将9位+64位整体做加密，生成73位的密文 字符校验算法，采用摘要，将73位的密文做hash digest，然后简单取余数: %(2^6)，结果是6位\n   序列号位数 能表示的个数上限 对应bit二进制位数     10     11     12     13 876488338465357800 59.604513                   如何校验： 默认客户端或者服务端的简单校验可以使用校验位：把前73位的字符%(2^6)，于后6位的校验字符比较，相等说明校验通过 将73位密文解密，得到9位payload+64位整型数据，对应appid+lastNumber，去数据库里查询记录即可。数据库主键设置为lastNumber(INT) 具体实现如下\n技术要求 再来说说其它技术要求\n 高效 防爆刷 防重复兑换  ","date":"0001-01-01","permalink":"/posts/notes/%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E9%80%BB%E8%BE%91/%E5%85%91%E6%8D%A2%E7%A0%81%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90/","series":null,"tags":null,"title":""},{"categories":null,"content":"什么是云原生 前言 要有明确的认识：云原生一直在发展变化。技术的变革，一定是思想先行，所以首先可以体会到，云原生是一种思想驱动的技术。\n软件设计有两个关键目标：高内聚、低耦合，围绕这2个核心目标，又提出了单一职责、开闭原则、里氏替换、依赖倒置、接口隔离、最少知识等设计原则。\n软件工程师一直都在为这两个目标而努力奋斗，以求把软件编写得更加清晰、更加健壮、更加易于扩展和维护。\n再后来，软件行业的诉求时希望开发软件变得更简单、更快捷，软件工程师更少编写代码，非专业人员也希望能开发程序，于是，更多的更傻瓜的编程语言被发明出来，更多的编程技术和编程思想被发明出来，比如库、组件、云基础设施。\n于是很多技术变成了屠龙之技，比如汇编，时代变了，建国后动物不能成精了，没有龙可以宰了，然后很多软件工程师摇身一变成了调参工程师、Call API砖家、用库包能手、拼组件达人，这是效率分工的结果，也是技术发展的使然。\n纵观近二十年的科技互联网发展历程，大的趋势是技术下沉，特别是近些年，随着云计算的发展和普及，基础设施越来越厚实，业务开发变得越来越容易，也越来越没有技术含量，而之前困扰小团队的性能、负载、安全性、扩展性问题都不复存在，这不禁让互联网行业的油腻大叔们噤若寒蝉，仿佛分分钟就要被卷入历史洪流而万劫不复。\n虽然不可否认技术的重要性在降低，但也还不至于那么悲观。遥想PC时代，当VB、Delphi、MFC出现的时候，也有类似论调，所见即所得，点点鼠标，就可以开发PC桌面程序，是不是很高端？那时候码农的担心相比现在恐怕是只多不少吧，但后来随着互联网兴起，出现了后端开发这个工种，码农很快找到了新的战场，网络、分布式、数据库、海量服务、容灾防错，于是又玩出一堆新花样。\n如果说PC时代的基础设施是控件库，互联网时代的基础实施是云，那AI时代基础设施是什么？又会有什么高端玩法？\n解释 准确来说，云原生是一套方法论，也是一套或多套技术体系。我们用它来构建和运行应用程序。\n 云-Cloud：应用首先都部署和运行在云服务器上，而非传统主机上 原生-Native：应用天生就要支持部署和运行在云上，天生要为了云环境而设计；最终得以在云环境中平稳、淋漓精致的、以一种最佳的方式运行；完全利用了云环境的弹性的、分布式的能力，发挥出云环境的特色  以上是抽象的以表述形式来简单形容云原生的定义。而市场上对其定论都是主观性的，各有侧重点。以下为例：\n Pivotal公司：DevOps、持续交付、微服务、容器 云原生计算基金会（CNCF）：容器化封装、自动化管理、面向微服务、服务网格(Service Mesh)、声明式API  特点 看吧，关注的点不一样，意味着定义的方向也不一样。\n至少在我们的理解来看，云原生应该是有以下特点的，或者说符合云原生的应用程序应当具有以下特点：\n 采用开源堆栈（K8S+Docker）进行容器化 基于微服务架构提高灵活性和可维护性 构建应用简便快捷，部署应用轻松自如；借助敏捷方法、DevOps支持持续迭代和运维自动化 运行应用按需伸缩：利用云平台设施实现弹性伸缩、动态调度、优化资源利用率  要素 微服务 组织架构决定产品形态，云原生下的应用使用微服务，能将服务通过func解耦，高内聚\n容器化 把应用部署在隔离的docker中，通过K8S做容器编排、管理、负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。\nDevOps 开发、运维合体，捎带上测试，一起为云原生提供持续交付能力。\n所以从理解上来看，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式和流程，也需要很多工具来支撑。\n持续交付 有别于传统瀑布式开发模型，持续交付是不误时开发，不停机更新，不间断小步快跑。\n如何去应用 首先，云原生借了云计算的东风，没有云计算，自然没有云原生，云计算是云原生的基础。\n随着虚拟化技术的成熟和分布式框架的普及，在容器技术、可持续交付、编排系统等开源社区的推动下，以及微服务等开发理念的带动下，应用上云已经是不可逆转的趋势。\n云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。\n1.本地部署的传统应用往往采用c/c++、企业级java编写，而云原生应用则需要用以网络为中心的go、node.js等新兴语言编写。\n2.本地部署的传统应用可能需要停机更新，而云原生应用应该始终是最新的，需要支持频繁变更，持续交付，蓝绿部署。\n3.本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。\n4.本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。\n5.本地部署的传统应用通常人肉部署手工运维，而云原生应用这一切都是自动化的。\n6.本地部署的传统应用通常依赖系统环境，而云原生应用不会硬连接到任何系统环境，而是依赖抽象的基础架构，从而获得良好移植性。\n7.本地部署的传统应用有些是单体(巨石)应用，或者强依赖，而基于微服务架构的云原生应用，纵向划分服务，模块化更合理。\n可见，要转向云原生应用需要以新的云原生方法开展工作，云原生包括很多方面：基础架构服务、虚拟化、容器化、容器编排、微服务。幸运的是，开源社区在云原生应用方面做出了大量卓有成效的工作，很多开源的框架和设施可以通过拿来主义直接用，2013年Docker推出并很快成为容器事实标准，随后围绕容器编排的混战中，2017年诞生的k8s很快脱颖而出，而这些技术极大的降低了开发云原生应用的技术门槛。\n虽说云原生的推介文档有引导之嫌，但面对它列举的优点，作为杠精的我亦是无可辩驳。这么说的话，云原生也忒好了吧，应用是不是要立刻马上切换到云原生架构？我的观点是：理想很丰满，现实经常很骨感，需从应用的实际需要出发，目前的问题是否真的影响到业务发展，而推倒重来的代价能否承受得来。\n","date":"0001-01-01","permalink":"/posts/notes/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E5%8E%9F%E7%94%9F/","series":null,"tags":null,"title":""},{"categories":null,"content":"单例和原型的区别 ","date":"0001-01-01","permalink":"/posts/notes/%E5%8D%95%E4%BE%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","series":null,"tags":null,"title":""},{"categories":null,"content":"// 基本状况\nfree -h // 应用程序物理内存消耗\nps -eo rss | awk \u0026lsquo;BEGIN{sum=0}{sum=sum+$1}END{print sum}\u0026rsquo; // 应用程序状况\ntop -b -n 1 cat /proc/meminfo 清理buffer cache $ sync\n将内存中数据强制先刷新到磁盘中 清理Buffer缓存区域 $ echo 1 \u0026gt; /proc/sys/vm/drop_caches # 表示清除pagecache。 $ echo 2 \u0026gt; /proc/sys/vm/drop_caches # 表示清除回收slab分配器中的对象（包括目录项缓存和inode缓存）。slab分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的pagecache。 $ echo 3 \u0026gt; /proc/sys/vm/drop_caches # 表示清除pagecache和slab分配器中的缓存对象\n","date":"0001-01-01","permalink":"/posts/notes/%E6%8E%92%E6%9F%A5linux%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/","series":null,"tags":null,"title":""},{"categories":null,"content":"搞懂JUC https://mp.weixin.qq.com/s/mmaTmHzWxIVDe_bvy5nz_w\n","date":"0001-01-01","permalink":"/posts/notes/%E6%90%9E%E6%87%82juc/","series":null,"tags":null,"title":""},{"categories":null,"content":"证书相关 什么是私钥？什么是证书？ 数字签名通常定义了两种运算： 签名和验签。发送者用自己的私钥对消息的哈希值进行签名，接收者用对方的公钥进行验签。因此，在使用数字签名时，需要通信的双方都要事先生成公钥、私钥，并且完成双方的公钥交换。其中，私钥是只能由拥有者使用的不公开密钥，公钥是可以公开的密钥。\n由于公钥本身并不含有拥有者的身份信息，使用时无法确认它是真实有效的。所以需要证书认证机构（简称 CA）在核实公钥拥有者的信息后，将公钥拥有者的身份信息（如商户号、公司名称等），公钥、签发者信息、有效期以及扩展信息等进行签名，制作成“证书”。\n","date":"0001-01-01","permalink":"/posts/notes/%E8%AF%81%E4%B9%A6%E7%9B%B8%E5%85%B3/","series":null,"tags":null,"title":""},{"categories":null,"content":"Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).\n![_config.yml]({{ site.baseurl }}/images/config.png)\nThe easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the Jekyll Now repository on GitHub.\n","date":"0001-01-01","permalink":"/posts/notes/2014-3-3-hello-world/","series":null,"tags":null,"title":"You're up and running!"},{"categories":null,"content":"C-\u0026gt;iOS-\u0026gt;javascript-\u0026gt;Java-\u0026gt;Go\n","date":"0001-01-01","permalink":"/posts/notes/2019-06-14-the-road-to-engineering/","series":null,"tags":null,"title":"我的编程之路"}]