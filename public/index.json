[{"categories":"iOS cer p12","content":"理解iOS开发证书 术语解释 cer 一种文件格式，存储的是公钥，学名证书\n如何生成cer  der二进制编码（cer有别于ber、der） base64编码  der 二进制格式，不可读，Java和Windows服务器偏向使用这种格式 DER格式的证书基于X.509标准\nPKCS#12 一个公钥加密的标准，总共有15个\np12 .p12是基于PKCS#12标准生成的一种文件格式，存储的是私钥 mac系统下在keychains钥匙串中找到证书-\u0026gt;导出-\u0026gt;p12就可以\n数字证书 无论是cer还是p12，广义上说都可以被称为数字证书。 | 什么是数字证书呢？数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（CertificateAuthority）中心发行的，人们可以在网上用它来识别对方的身份。在当今这个互联网时代，已经成为了必不可少，不可或缺的一个过程。\n PEM pem文件是p12文件转换后的一种文件格式，存储的也是密码（私钥还是公钥？），内容是BASE64编码 以\u0026mdash;\u0026ndash;BEGIN开头，\u0026mdash;\u0026ndash;END结束 Apache和Linux、Unix服务器偏向使用这种编码格式 PEM格式的证书基于X.509标准\nHttps和Http关于s的区别以及SSL OpenSSL 是SSL规范的一种实现。它还提供了一些工具软件，SSL证书需要符合的是一种标准X.509、RFC5280\n证书编码格式的问题 证书编码格式常见的有pem和der，但是文件扩展名并一定就是它俩，证书可以转换为其它编码格式，内容也有差别\n证书格式  CRT CER KEY PFX/p12 JKS  CSR Certificate Signing Request, 证书签名请求，用户生成公私钥，私钥自己保存好，公钥作为申请内容，向证书颁发机构申请获得签名证书\niOS证书申请、到发布、再到用户安装过程中的流程 ![]({{ site.baseurl }}/images/apple_auth_process.png)\n","date":"2020-01-16","permalink":"/posts/notes/2020-01-16-ios-develop-certificate-understanding/","series":null,"tags":null,"title":"ios develop certificate understanding"},{"categories":"fabric","content":"charactoristics on hyperledger fabric 一个标准的可认为是最佳实践的fabric项目应当具备的特性   初始配置\n  各组件启动\n  通道创建和加入\n  链码的注册和实例化\n  界面化的demo演示交易的调用\n  blockchain explorer启动和查看运行、网络、区块、交易\n  demo应用监听事件\n  多级证书配置和可插拔\n  动态加入和撤出组织\n  更换排序共识插件\n  组件无限扩展\n  账本、状态的存储结构替换\n  多通道\n   ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-charactoristics-on-hyperledger-fabric/","series":null,"tags":null,"title":"charactoristics on hyperledger fabric"},{"categories":"AST","content":"抽象语法树AST https://baijiahao.baidu.com/s?id=1626159656211187310\u0026amp;wfr=spider\u0026amp;for=pc\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-ast/","series":null,"tags":null,"title":"learn ast"},{"categories":"flow","content":"design a flow based develop and invoke system todo cabala重构点： 根据接口查脚本 根据脚本反查接口\n脚本写完模拟调用 接口写完模拟调用\n管理页面提取成一套，根据接口名称和脚本名称查询 搜索规则有：list，count，save，get，edit，remove，其它\n业务模块-\u0026gt;接口 -\u0026gt;脚本(脚本中指定库)\n开始结束 循环、判断 数据库操作 缓存操作\n调用子服务 同步和异步\n从原始接口表更新到目标接口表：指定接口号和脚本代码即可，自动拉取同步，自动刷新缓存，永不重启引擎服务\n开启提示模式时，节点入出的参数都展示出来\n判断、循环的代码段可以边编辑边拷贝参考\n接口流程图直接生成一个单独文件，并保存至文件服务器\n接口流程图可以映射到文档文件，文档文件可以直接生成接口流程图\n接口流程图有专门的查看搜索等管理，选择环境可以查看，各节点全部展示出出入参\n接口可以导入导出流程图\n每天自动把节点\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-design-a-flow-based-develop-and-invoke-system/","series":null,"tags":null,"title":"design a flow based develop and invoke system"},{"categories":"shell","content":"learn shell from start 打印日期的两种方式 echo today is `date \u0026#34;+%Y-%m-%d\u0026#34;` echo today is $(date \u0026#34;+%Y-%m-%d\u0026#34;) shell中变量的使用 mypid=$$ echo \u0026ldquo;mypid:$mypid\u0026rdquo;\nparamCount=$# echo \u0026ldquo;paramCount:$paramCount\u0026rdquo;\nlastPid=$! echo \u0026ldquo;lastPid:$lastPid\u0026rdquo;\nlastResponse=$? echo \u0026ldquo;lastResponse:$lastResponse\u0026rdquo;\nsetFlag=$- echo \u0026ldquo;setFlag:$setFlag\u0026rdquo;\nparams=$* echo \u0026ldquo;params:$params\u0026rdquo;\nstringParams=$@ echo \u0026ldquo;stringParams:$params\u0026rdquo;\nparam0=$0 echo \u0026ldquo;param0:$param0\u0026rdquo;\nparam1=$1 echo \u0026ldquo;param1:$param1\u0026rdquo; printf \u0026ldquo;param1 is %s\\n\u0026rdquo; $param1\nfor i in $@; do echo $i done\nfor i in $params; do echo $i done\n`` 和 $() 里面的都是命令 echo Linux echo Shell echo today is date \u0026quot;+%Y-%m-%d\u0026quot;``` echo Linux echo Shell $(echo today is $(date \u0026ldquo;+%Y-%m-%d\u0026rdquo;))` echo Linux $(echo Shell $(echo today is $(date \u0026ldquo;+%Y-%m-%d\u0026rdquo;)))\n${}里面的是变量 A=Charlie echo \u0026ldquo;variable AB is: $AB\u0026rdquo; echo \u0026ldquo;variable A($A) concat charactor B is: ${A}B\u0026rdquo;\nfile=/Users/huray/Desktop/testshell.sh\n#是去掉左边(在键盘上 # 在 $ 之左边) % 是去掉右边(在键盘上 % 在 $ 之右边) 单一符号是最小匹配;两个符号是最大匹配 *是用来匹配不要的字符，也就是想要去掉的那部分 还有指定字符分隔号，与*配合，决定取哪部分 拿掉第一条 / 及其左边的字符串 echo ${file#*/}\n拿掉最后一条 / 及其左边的字符串 echo ${file##*/}\n拿掉第一个 . 及其左边的字符串 echo ${file#*.}\n拿掉最后一个 . 及其左边的字符串 echo ${file##*.}\n拿掉最后一条 / 及其右边的字符串 echo ${file%/*}\n拿掉第一条 / 及其右边的字符串 echo ${file%%/*}\n拿掉最后一个 . 及其右边的字符串 echo ${file%.*}\n拿掉第一个 . 及其右边的字符串 echo ${file%%.*}\n参考文档 https://www.cnblogs.com/chengd/p/7803664.html\n目录和路径的获取 https://blog.csdn.net/Jerry_1126/article/details/79872110\n循环 for((paramIdx=1; paramIdx\u0026lt;10; paramIdx++)); do eachParam=$paramIdx echo \u0026ldquo;eachparam:$eachParam\u0026rdquo; done pcount=$# if ((pcount==0)); then echo no args; exit; fi  #2 获取文件名称 p1=$1 fname=basename $p1  echo $fname  #3 获取上级目录到绝对路径 pdir=cd -P $(dirname $p1); pwd echo $pdir  #4 获取当前用户名称 user=whoami  #5 循环 for((host=1; host\u0026lt;4; host++)); do echo \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- hadoopnode0$host \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; rsync -av $pdir/$fname $user@hadoopnode0$host:$pdir done ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-shell-from-start/","series":null,"tags":null,"title":"learn shell from start"},{"categories":"algorithms","content":"byzantine：拜占庭问题的算法 https://www.zhihu.com/question/30288330\n1.5（P - E） \u0026gt; P 3 / 2 * P - 3 / 2 * E \u0026gt; P 1 / 2 * P \u0026gt; 3 / 2 * E P \u0026gt; 3 E 1 / 3 * P \u0026gt; E\n如果系统中有n个故障节点，系统要想正确运行，必须至少要有2n+1个正常节点\nP = N + E N \u0026gt; X \u0026gt; N/2 + E\n1.5N \u0026gt; N + E\n1 / 2 N \u0026gt; E N \u0026gt; 2E\n所有正确的节点最终会决定一个值（termination） 所有正确的节点决定的值必须相同（agreement） 所有正确的节点决定的值必须是被正确的节点提出来的（validity）\n消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的\n安全的互相传递消息的前提下，一个忠臣提出的意见和其它忠臣的意见都相同，最终所有忠臣都同意这个意见。 我们要确定的就是需要最少几个忠臣。 分布式网络下需要最少几个正确节点\n延伸问题 ProofOfWork ProofOfStake 比特币、以太坊等的共识算法\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-byzantine/","series":null,"tags":null,"title":"byzantine"},{"categories":"distributed","content":"distributed system learn key point ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-distributed-system-learn-key-point/","series":null,"tags":null,"title":"distributed system learn key point"},{"categories":"maven","content":"maven project directory standard ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-maven-project-directory-standard/","series":null,"tags":null,"title":"maven project directory standard"},{"categories":"Java","content":"parse request url ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-parse-request-url/","series":null,"tags":null,"title":"parse request url"},{"categories":"linux","content":"CentOS7关闭SELinux [root@dev-server ~]# getenforce Disabled [root@dev-server ~]# /usr/sbin/sestatus SELinux status: disabled # 永久关闭 vi /etc/selinux/config # 将SELINUX=enforcing改为SELINUX=disabled # 重启后生效 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-linux-close-selinux/","series":null,"tags":null,"title":"linux close selinux"},{"categories":"linux","content":"centOS7永久关闭防火墙 # 查看状态 systemctl status firewalld.service # 关闭 systemctl stop firewalld.service # 开机禁用 systemctl disable firewalld.service # 开启 systemctl start firewalld.service # 开机启用 systemctl enable firewalld.service ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-operate-linux-firewall/","series":null,"tags":null,"title":"operate linux firewall"},{"categories":"orm","content":"learn hibernate mybatis and orm todo hibernate mybatis ORM\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-learn-hibernate-mybatis-and-orm/","series":null,"tags":null,"title":"learn hibernate mybatis and orm"},{"categories":"database","content":"数据库设计的原则 简单记录几点要点  符合业务需求 避免冗余  数据仓库设计要以哪些指标为主？  需求 维度 指标  数据库的需求和数据仓库需求的不同  数据库要求的是实时，一致 数据仓库要求的是汇总数据有效，全量，不需实时  数据仓库产生的因素 数据仓库产生于数据库之上，为了进一步挖掘数据资源、决策需要而存在\n","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-database-design/","series":null,"tags":null,"title":"database design"},{"categories":"mysql","content":"derby and mysql todo derby 哪些方面能代替mysql MariaDB 为什么是mysql的分支 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-derby-and-mysql/","series":null,"tags":null,"title":"derby and mysql"},{"categories":"linux","content":"查询linux中各种状态的tcp连接 netstat -ant |grep CLOSE_WAIT|wc -l 同理可替换CLOSE_WAIT为  TIME_WAIT ESTABLISHED  ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-query-linux-tcp-exceptional-tcp-connections/","series":null,"tags":null,"title":"query linux tcp exceptional tcp connections"},{"categories":"Java","content":"Array和ArrayList的各自特点和区别 Array  内存中是连续的 读取和赋值很快 扩容和收缩很慢 需要指定内存大小  ArrayList  不需要指定容量 方便动态扩容和收缩 可以保存不同类型，本质都当作Object处理 ArrayList不是类型安全，需要拆装箱 通过指定泛型，通过编译来强制使用正确统一的数据类型，也减少了类型转换  ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-difference-from-array-and-arraylist/","series":null,"tags":null,"title":"difference from array and arraylist"},{"categories":"mysql","content":"清楚重复数据 建表 CREATE TABLE `src5` ( `userid` int(11) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(20) DEFAULT NULL, `usercode` varchar(20) DEFAULT NULL, PRIMARY KEY (`userid`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; 如果usercode重复，那么可能会出现以下数据 userid username usercode 1 \u0026hellip; code0 2 \u0026hellip; code0 3 \u0026hellip; code0\n删除id最大的那一行，比如删除code0，userid为3的那行 DELETE FROM src5 WHERE userid IN ( SELECT id FROM ( SELECT MAX(userid) AS id, COUNT(usercode) AS ucount FROM src5 GROUP BY usercode HAVING ucount \u0026gt; 1 ORDER BY ucount DESC ) tab ) 如果没有自增主键，需要先临时增加，以tmpid为count ALTER TABLE src5 ADD COLUMN tmpid INT(11) PRIMARY KEY AUTO_INCREMENT; 最后再删除 ALTER TABLE src5 DROP COLUMN tmpid; 同时修改原来的主键column ALTER table table_name add PRIMARY KEY (user_role_id) ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-delete-dirty-lines-in-mysql/","series":null,"tags":null,"title":"delete dirty lines in mysql"},{"categories":"resume","content":"写好一份技术简历的要点 几个注意点  框架是重点，但别让人感觉你只会山寨别人的代码 别单纯看单机版的框架，适当了解些分布式 数据库方面，别就知道增删改查，得了解性能优化，NoSQL亦如此 Java核心方面，围绕数据结构和性能优化准备面试题 Linux方面，至少了解如何看日志排查问题 通读一些底层代码，作为加分项  一切的一切，把上述技能嵌入到你做过的项目里 ","date":"2020-01-15","permalink":"/posts/notes/2020-01-15-how-to-descripe-in-resume/","series":null,"tags":null,"title":"how to descripe in resume"},{"categories":"work","content":"write work summary 总结中必须包含的几大内容点  工作中暴露问题 某些方案提出合理的方案 自己工作中的提升 对来年的展望 未来公司的规划、个人的规划  工作总结要可以体现出以下特点  精确 准确、量化 对公司核心的作用 工作重要性的排列 可以借鉴给他人复用的工作经验 必要的反思 来年工作计划、思考、体现出热情  其它补充的点  应当适当表明成功来源于领导 征求领导的建议 不告状 *不带情绪  ","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-write-work-summary/","series":null,"tags":null,"title":"write work summary"},{"categories":"shell","content":"how to post by shell 本篇文章留存，用作帮助使用shell去快速发布一篇文章\n","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-how-to-post-by-shell/","series":null,"tags":null,"title":"how to post by shell"},{"categories":"shell","content":"how to auto publish post 我这里使用的是zsh\n#!/bin/zsh ","date":"2020-01-14","permalink":"/posts/notes/2020-01-14-how-to-auto-publish-post/","series":null,"tags":null,"title":"how to auto publish post"},{"categories":"english","content":"转载   This approach has several drawbacks for users. Therefore, before considering this approach, make sure that it will not negatively impact the user experience.  ","date":"2019-10-28","permalink":"/posts/notes/2019-10-28-sentences-each-day/","series":null,"tags":null,"title":"sentences each day"},{"categories":"nginx","content":"转载  vim /usr/local/etc/nginx/nginx.conf sudo nginx -s reload ","date":"2019-10-28","permalink":"/posts/notes/2019-10-28-shortcuts-for-nginx/","series":null,"tags":null,"title":"shortcuts for nginx"},{"categories":"sh","content":"转载 scp scp /data/somefile.sometype tomcat@destinationhost:/data/newfile.type tar press:\ntar czf result.tar.gz sourcefile/ unpress:\ntar xzf result.tar.gz sourcefile/ ","date":"2019-10-21","permalink":"/posts/notes/2019-10-21-how-to-use-scp-and-tar/","series":null,"tags":null,"title":"how to use scp and tar"},{"categories":"sh","content":"转载 guideline https://zhuanlan.zhihu.com/p/37195261\ndylib error https://discourse.brew.sh/t/library-not-loaded-usr-local-opt-gdbm-lib-libgdbm-4-dylib/2647/5\n","date":"2019-10-10","permalink":"/posts/notes/2019-10-10-use-iterm2-and-oh-my-zsh-to-replace-terminal/","series":null,"tags":null,"title":"use iterm2 and oh-my-zsh to replace terminal"},{"categories":"jdk","content":" 示例 # 查看flutter环境 flutter doctor # 升级flutter flutter upgrade # 查看flutter版本分支 flutter channels ","date":"2019-08-09","permalink":"/posts/notes/2019-07-30-how-to-install-flutter-on-mac/","series":null,"tags":null,"title":"how to install flutter on mac"},{"categories":"jdk","content":"AbstractQueuedSynchronizer Lock 使用Lock接口是java实现锁的一种方式。 Lock接口在java.util.concurrent.locks包下。 ReentrantLock(可重入锁)、ReadLock(读锁)、WriteLock(写锁)是Lock接口最重要的三个实现类。 ReadWriteLock接口是一个工厂接口，ReentrantReadWriteLock是ReadWriteLock接口的实现类，它包含两个内部静态类ReadLock(读锁)、WriteLock(写锁)，这两个静态类又分别实现了Lock接口。\n悲观锁与乐观锁的定义 它们是在并发情况下的两种不同策略。java中没有明确的类就是乐观锁或者悲观锁。\n  悲观锁的策略： 就是很悲观，认为每次去拿的数据可能被别人修改过了。所以，自己去拿数据的时候会上锁，导致别人等到锁被释放才能获取数据。\n  乐观锁的策略： 每次去拿数据的时候认为别人不会修改，不上锁。 只是在更新的时候采用一种特殊方式，因为更新分为三步，先读取、然后检查、最后更新；所以在更新之前要先检查读取的数据是不是已经被别人修过过了。如果修改过了，就重新读取，再次重复检查步骤最后更新。 有的情况下，更新失败的所在的线程可能会放弃操作。\n  比较 所以说 悲观锁阻塞事务，乐观锁回滚重试。\n  对于写少的情况，即冲突少，采用乐观锁，可以省去锁的开销，增加数据系统的吞吐量。 如果冲突多，不断地回滚重试反倒是降低性能，不如采用悲观锁合适。\n乐观锁的回滚重试 通常把这种策略用概念CAS表示：Compare-and-swap\n","date":"2019-08-09","permalink":"/posts/notes/2019-08-09-abstract-queued-synchronizer/","series":null,"tags":null,"title":"AbstractQueuedSynchronizer"},{"categories":"jdk","content":"Mac下查看已安装的jdk版本及其安装目录 示例 /usr/libexec/java_home -V ","date":"2019-07-30","permalink":"/posts/notes/2019-07-30-find-java-path/","series":null,"tags":null,"title":"find java path"},{"categories":"math","content":"https://zhuanlan.zhihu.com/p/48307582\n如何证明π为常数？ \u0026ndash;为什么π是一个常数？即为什么所有圆的周长和直径之比为一个定值？\n解答： 小圆的半径r1，周长c1；大圆的半径r2，周长c2 小圆内切正n边形，边长为k1；大圆内切正n边形，边长为k2 OA:OD=OB:OC；角AOB = 角COD；三角形OAB全等于三角形OCD ∴ k1:r1=k2:r2 设小正n边形周长为c1',大正n边形周长为c2' c1'=nk1,c2'=nk2 c1':r1=c2':r2 当n等于无限大时，c1'=c1,c2'=c2 ∴ c1:r1=c2:r2\n所以，对于半径不同的圆，各自周长除以半径为定值（常数），记该常数为2π， 则周长除以直径为π 证明π为常数\n","date":"2019-07-24","permalink":"/posts/notes/2019-07-24-how-to-prove-pi/","series":null,"tags":null,"title":"how to prove pi"},{"categories":["mysql"],"content":"MySQL SQL GROUP BY是如何选择哪一条数据留下的 示例 -- 建表 CREATE TABLE `src2` ( `id` int(11) DEFAULT NULL, `name` varchar(20) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 查询 SELECT id, name FROM src2; 查询到的结果 id name 1 alpha 1 bravo 2 charlie 2 dolphin\n查看当前mysql版本，并且看是否开启了only full group by SELECT version(), @@sql_mode; 5.7.20 STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n根据id使用group by查询id,name SELECT id, NAME FROM src2 GROUP BY id; 如无异常会查询到两条数据，但是同样为id1的两条数据是如何选择留哪一条呢 1 alpha 2 charlie\n稍后再看，先解决这个问题 关闭only full group by -- 去除 SET sql_mode=(SELECT REPLACE(@@sql_mode,\u0026#39;ONLY_FULL_GROUP_BY\u0026#39;,\u0026#39;\u0026#39;)); -- 再次查询 SELECT version(), @@sql_mode; 如何恢复？ 5.7之前的mysql其实是处于未定义规则状态，官方文档不承诺一定会返回哪条数据。而到了MySQL5.7，仍然是未定义状态，并且默认直接不允许未定义状态的grouping查询，会报错：\nExpression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'learn.src2.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by -- 重新开启only full group by SET sql_mode=(SELECT CONCAT(@@sql_mode, \u0026#39;,ONLY_FULL_GROUP_BY\u0026#39;)); 那么查询的重复id的数据应该返回哪一条呢 要看查询具体使用的b-tree索引中第一个命中的数据。\n如何优化或者改变查询方式 -- 加入max条件或者其它 SELECT * FROM src2 WHERE NAME IN (SELECT max(NAME) FROM src2 GROUP BY id) ORDER BY id ASC 参考mysql文档： group by handling ","date":"2019-07-10","permalink":"/posts/notes/2019-07-10-mysql-only-full-group-by/","series":["MySQL由浅入深"],"tags":["语法"],"title":"mysql only full group by"},{"categories":"encrypt","content":"在mysql中对字符串aes加密和解密 直接上函数 # 加密 SELECT HEX(AES_ENCRYPT(\u0026#39;123456\u0026#39;,\u0026#39;root\u0026#39;)) # 解密 SELECT AES_DECRYPT(unhex(\u0026#39;537AB41AAABDEC3BAB09BE15392B916A\u0026#39;), \u0026#39;root\u0026#39;) ","date":"2019-07-10","permalink":"/posts/notes/2019-07-10-aes-encrypt-in-mysql/","series":null,"tags":null,"title":"aes encrypt in mysql"},{"categories":"linux","content":"centos搭建docker私有仓库 安装docker 略过\n# 重启docker systemctl daemon-reload systemctl restart docker 拉取仓库镜像 docker pull registry 运行仓库 docker run -d -v /registry:/var/lib/registry -p 5000:5000 --restart=always --privileged=true --name registry registry:latest 示例:从官方仓库拉取hello-world docker pull hello-world 给hello-world镜像打个tag，表示新的版本 docker tag hello-world 127.0.0.1:5000/hello-world:latest 推送：将新的hello-world镜像上传到私有仓库 docker push 127.0.0.1:5000/hello-world:latest 在私有仓库查看上传的镜像 ls /registry/docker/registry/v2/repositories 通过客户端查看镜像\ncurl http://127.0.0.1:5000/v2/_catalog 输出:\n{\u0026#34;repositories\u0026#34;:[\u0026#34;hello-world\u0026#34;]} ","date":"2019-06-28","permalink":"/posts/notes/2019-06-28-install-docker-registry-on-centos/","series":null,"tags":null,"title":"install docker registry on centos"},{"categories":"jekyll update","content":"如何在mac上安装jykell\n1.安装rvm\ncurl -L get.rvm.io | bash -s stable source ~/.rvm/scripts/rvm rvm -v  2.安装ruby\nrvm install 2.6.0 rvm list  3.安装jykell\ngem source gem install jekyll jekyll -version  4.安装bundle\ngem install bundle 运行bundle，安装Gemfile里的插件 bundle install  5.初始化web项目\njekyll new r2ys-site cd r2ys-site/  6.本地localhost:4000测试\njekyll serve jekyll serve --watch --baseurl '/blog'  7.内容生成\njekyll build  You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.\nTo add new posts, simply add a file in the _posts directory that follows the convention YYYY-MM-DD-name-of-post.ext and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.\nJekyll also offers powerful support for code snippets:\n{% highlight java %} System.out.prinln(\u0026quot;\u0026quot;); def print_hi(name) puts \u0026ldquo;Hi, #{name}\u0026rdquo; end print_hi(\u0026lsquo;Tom\u0026rsquo;) #=\u0026gt; prints \u0026lsquo;Hi, Tom\u0026rsquo; to STDOUT. {% endhighlight %}\n{% highlight oc %} NSString *str = @\u0026ldquo;suck\u0026rdquo;; {% endhighlight %}\n![avatar]({{ site.baseurl }}/assets/201812121137485b3b6458f4023.jpg)\nCheck out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo . If you have questions, you can ask them on Jekyll Talk .\n","date":"2019-01-08","permalink":"/posts/notes/2019-01-08-how-to-install-jykell-on-mac/","series":null,"tags":null,"title":"How to install jykell on mac!"},{"categories":null,"content":"","date":"0001-01-01","permalink":"/posts/notes/2020-01-14-%E5%A6%82%E4%BD%95-%E4%BD%BF%E7%94%A8-jekyll/","series":null,"tags":null,"title":""},{"categories":null,"content":"Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).\n![_config.yml]({{ site.baseurl }}/images/config.png)\nThe easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the Jekyll Now repository on GitHub.\n","date":"0001-01-01","permalink":"/posts/notes/2014-3-3-hello-world/","series":null,"tags":null,"title":"You're up and running!"},{"categories":null,"content":"C-\u0026gt;iOS-\u0026gt;javascript-\u0026gt;Java-\u0026gt;Go\n","date":"0001-01-01","permalink":"/posts/notes/2019-06-14-the-road-to-engineering/","series":null,"tags":null,"title":"我的编程之路"}]