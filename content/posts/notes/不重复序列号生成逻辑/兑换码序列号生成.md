# 兑换码/序列号生成
## 需求
* 16位字符串，包含数字或字母
* 随机性，无法猜测和暴力碰撞
* 永不重复
  

## 分析

* 给定的要求是永不重复，但往往业务的体量不同，上限也不同；假定单个业务类型下可支持的总量为1亿，技术上能实现10亿是否就能满足需求？
* 数字或字母，参考以往Base32编码表中字母为A-Z共26个，数字为234567，去掉了容易混淆的0、1、8、9；32个字符随机是否也能满足需求？



## 生成流程

* 

## 生成原理

先逆向考虑

32个字符的编码表最多表示多少个数？

1个字符能表示32个数：0,1,2,...,30,31对应A,B,C,...,6,7

2个字符能表示1024个数: 0,1,2,...,30,31,32,33,34,...,1022,1023对应A,B,C,...,6,7,AB,AC,AD,...,ZX,ZY

结论：1个字符表示32^1个数；2个字符表示32^2个数

那么32个字符表示32^32个数，约为1.4e48，支持10^40个亿。

16位字符能表示的最多有32^16个数，约为1.2e24，10^16个亿，肯定能包含在32字符编码所支持的范围，也自然远超过需求的1亿个数，我们以技术能支持的上限10亿作为目标。

接下来，怎么表示这10亿个数，用字符串、浮点、整型肯定是不理想的，我们选择用bit来表示，java中byte字节是8个bit：

1bit能表示2^1个数，以int32位无符号整数举例，32bit能表示2^32个数，float64bit能表示2^64个数

所以log2(10亿)能表示10亿个数，也就是29.897353bit能表示10亿个数，约为30bit。

log2(32^16)能表示10^16亿个数，约为80bit。

我们使用超过30bit的值来表示这10亿个数即可，**那么如何确定bit使用多少位？用bit表示的值怎么转换成16位字符？**

我们计划使用Base32编码表中的编码来表示最终的16位字符，Base32的转换方式是这样的，每5bit作为一个小节，5bit有2^5也就是32种情况，每种情况对应一个0-31的数值，根据下标也就能对应一个编码。

举例如下：

```java
// 字节数组byte[]中存放了2个byte字节也就是16bit的short类型的数据：127 127
// 对应二进制表示为：01111111 01111111
// 将二进制作5位一个小节的拆分：01111 11101 11111 1base32中的编码表是：
// 末位不够5位的后边补0: 01111 11101 11111 10000
// 对应的数值就是：15 29 31 16
// base32中的编码表是：ABCDEFGHIJKLMNOPQRSTUVWXYZ234567
// 所以对应的下标：15:P 29:5 31:7 16:Q
// 将byte[(byte)127,(byte)127]进行base32编码的结果是：P57Q
```

回到刚才的问题，如何确定bit使用多少位？用bit表示的值怎么转换成16位字符？

用base32可以将76-80bit的数值转换成16位字符；根据最终序列号长度n的要求，使用(5(n-1),5n]来表示bit位数。

java以uff-8编码的数据类型中，byte8bit、short16bit、int32bit、long64bit、英文数字字符char8bit、中文字符char24bit。

为了实现16位序列号，bit总长度为80bit，数值长度需要>30bit，有两种选择，int32bit和long64bit，但因为我们考虑加一些payload、sign，选择int32bit即可，为其它位置预留空间。payload包含一些标记字段，如发行信息、序列号扩展信息、发行时间等。sign可以将payload和data合并之后的bit作哈希签名，方便客户端或者服务端的简单校验。

在此基础上，假定规划如下：

payload(32bit)+data(32bit)+sign(16bit)

* payload：使用长度为4字节的int，这里将业务应用的模版编号在数据库中的自增主键拿过来用，通常自增主键是bigint(8字节，能存2^64个整数)或int(4字节，能存2^32个整数，约40亿)，在字符串长度可以增加的情况下我们可以选择bigint，这里我们采用int作为payload中的模版编号。

* data: 使用长度为4字节的int
* sign: 将payload+data整体64bit作hash摘要，然后取余:%16，结果是2字节的sign

所以，如果是模版编号0，第一次获取的序列号用十进制数据表示为：

0 0 '7X'

对应二进制：

00000000000000000000000000000000 00000000000000000000000000000000 00000111 01011000

接下来，



采用base32，需要被base编码最大bit位数5和数据存储最小位数8整除

16个字符(80bit)：payload(32bit)+data(32bit)+sign(16bit)

24个字符(120bit)：payload(32bit)+data(64bit)+sign(24bit)

32个字符(160bit)：payload(64bit)+data(64bit)+sign(32bit)

10 12 15 16 20 24 25   

50 60 75 80 100 120 125

32 32 64 64 64 64 64

18 28 11 16 36 56 61

8^2 8^3 8^1 8^1 8^4 8^7 8^7

2  4 	3	0	4	0	5

24



1 固定256bits的密钥K、64bits的新鲜值N

2 将序号i与K还有N一起使用chacha20算法计算出512bits的伪随机数R

3 将R拆分成256bits的R1和R2，R1是hmac的salt，(i+payload+R2)作为明文，得到摘要H

4 将payload和摘要H拼接并截取前30bit，与R2的前30bits做异或，得到密文C

5  将i和c拼接组成59bits，使用base24算法转译



1. 输入参数为店铺编号、卡号、序号
2. 用ChaCha20算法对序号加密，得到一个512字节的随机数
3. 将步骤2生成的随机数取前256字节作为HMAC算法的密钥
4. 将序号、店铺编号、步骤2生成的随机数的后256字节拼成字节数组
5. 用步骤3生成的HMAC对步骤4生成的字节数组进行加密
6. 将店铺编号编码为27bit，步骤5生成的字节数组取前18bit，拼成45bit报文
7. 步骤4生成的字节数组取前45bit报文M1，步骤6生成的45bit报文M2，将M1和M2进行异或运算
8. 根据序号得到30bit的明文，步骤7得到45bit密文，将明文和密文拼接成75bit的激活码主体
9. 用ChaCha20算法对卡号进行加密，得到的随机数按字节求和，然后对32取模
10. 根据步骤9的结果，得到一套base32的编码方式，对步骤8产生的75bit激活码主体进行编码，得到15位的32进制数（大写字母和数字，排除掉0O1I）
11. 步骤9得到的结果进行base32编码得到一位32进制数
12. 将步骤11和步骤10得到的结果拼在一起，得到16位的激活码







1个字符能表示33个数：34^1-1=33
2个字符能表示1155个数：34^2-1=1155
16个字符能表示(34^16-1)个数
16个字符对应二进制数是81bit：log2(34^16-1)
需求上限如果是4亿个数，对应的二进制数是29bit: log2(4亿)
二进制数是29bit，选择使用32bit，正好是十进制int
那么16个字符一定能满足，而且只会占用极小部分

int32位无符号整数可以表示的数有(2^32-1)个：4294967295，约为42.9亿个数
需求按4亿，我们能满足40亿
最大值为:11111111111111111111111111111111
最小值为:00000000000000000000000000000000

既然16个字符能表示81位，那我们可以将一些标记、校验补充进去
假定分割的bit如下：
9位(用来存放一些payload)+64位(用来存放递增数据)+6位(用来字符校验)
64位用来存储数据，但是是加密后的数据，我们采用加密算法将9位+64位整体做加密，生成73位的密文
字符校验算法，采用摘要，将73位的密文做hash digest，然后简单取余数: %(2^6)，结果是6位

| 序列号位数 | 能表示的个数上限   | 对应bit二进制位数 |
| ---------- | ------------------ | ----------------- |
| 10         |                    |                   |
| 11         |                    |                   |
| 12         |                    |                   |
| 13         | 876488338465357800 | 59.604513         |
|            |                    |                   |
|            |                    |                   |
|            |                    |                   |



## 如何校验：
默认客户端或者服务端的简单校验可以使用校验位：把前73位的字符%(2^6)，于后6位的校验字符比较，相等说明校验通过
将73位密文解密，得到9位payload+64位整型数据，对应appid+lastNumber，去数据库里查询记录即可。数据库主键设置为lastNumber(INT)
具体实现如下



## 技术要求

再来说说其它技术要求

* 高效
* 防爆刷
* 防重复兑换